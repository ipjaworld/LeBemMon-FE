# HTML 파싱 워크플로우

## src/request 폴더의 HTML 파일 파싱

사용자가 `src/request/` 폴더에 HTML 파일을 제공할 때:

1. **HTML 파일 구조 파악**: 제공된 HTML 파일의 구조를 먼저 확인하고, 파싱할 데이터의 위치와 패턴을 파악한다.

2. **파싱 스크립트 위치**: HTML 파싱 스크립트는 `scripts/parse/` 디렉토리에 저장한다. 파일명은 `parse_{데이터타입}.py` 형식을 따른다 (예: `parse_html_items.py`, `parse_html_monsters.py`).

3. **파싱 스크립트 구조**:
   - HTML에서 데이터 추출 (예: `result-list-box` 클래스 내의 아이템들)
   - 데이터 타입에 맞는 카테고리 자동 분류 (이름 패턴 기반)
   - 기존 JSON 데이터 파일과 병합 (중복 제거 및 업데이트)
   - 결과를 해당 데이터 파일에 저장 (예: `src/data/item_data.json`)

4. **데이터 병합 규칙**:
   - 같은 ID가 이미 존재하면 업데이트 (새로운 데이터로 덮어쓰기)
   - 새로운 ID는 추가
   - ID 정렬: 숫자 ID는 숫자 순서로, 문자 ID는 문자열 순서로 정렬 (숫자 ID 우선)

5. **카테고리 자동 분류**: 아이템/데이터 이름에서 패턴을 분석하여 카테고리를 자동으로 결정한다. 예:
   - 아이템 이름에 "투구" → `minorCategory: "hat"`
   - 아이템 이름에 "귀 장식" 또는 "귀장식" → `minorCategory: "earring"`
   - 아이템 이름에 "상의" → `minorCategory: "top"`
   - 아이템 이름에 "하의" → `minorCategory: "bottom"`
   - 아이템 이름에 "신발" → `minorCategory: "shoes"`
   - 아이템 이름에 "장갑" → `minorCategory: "gloves"`
   - 아이템 이름에 "방패" → `minorCategory: "shield"`
   - 아이템 이름에 "망토" → `minorCategory: "cape"`
   - 아이템 이름에 "전신 갑옷" → `minorCategory: "full-body"`
   - 무기 카테고리는 명시적으로 제공되는 경우가 많으므로, 카테고리명과 매핑 딕셔너리를 사용한다

6. **실행 및 검증**:
   - 파싱 스크립트 실행 후 결과 확인 (추가/업데이트된 항목 수)
   - 린터 오류 확인
   - 데이터 파일 형식 검증

7. **사용자 요청 형식**: 사용자가 "result-list-box class의 데이터를 파이썬으로 파싱해서 데이터화 시켜서 우리 서비스에 반영해줘"라고 요청하면, 위 워크플로우를 따라 진행한다.

## HTML 테이블 형식 데이터 파싱

사용자가 HTML 테이블 형식으로 데이터를 제공할 때 (예: `<table class="listTable">` 또는 `<div id="tableContainer">`):

1. **테이블 구조 파악**: 
   - 테이블은 `<table class="listTable">` 형식 또는 `<div id="tableContainer">` 내부의 테이블로 제공될 수 있다
   - 각 행(`<tr>`)에서 필요한 데이터를 추출한다
   - 카테고리는 다음 두 가지 형식으로 구분될 수 있다:
     - 형식 1: 코드 블록 형식 (``` 카테고리명 ... ```)
     - 형식 2: HTML 주석 형식 (`<!-- 카테고리명 -->` ... `<!-- 카테고리명 끝 -->` 또는 `<!-- ``` 카테고리명 -->` ... `<!-- ``` -->`)
   - 여러 카테고리의 HTML을 한 번에 제공할 수 있으며, 각 카테고리는 위 형식 중 하나로 구분된다
   - `scripts/parse/parse_weapon_table.py`와 `scripts/parse/parse_equipment_table.py` 스크립트는 두 가지 형식 모두 지원한다

2. **사용자 입력 처리 워크플로우**:
   - 사용자가 HTML 파일을 직접 제공하거나 HTML 텍스트를 제공할 수 있다:
     - **방법 1**: 사용자가 이미 `src/request/` 폴더에 HTML 파일을 만들어 제공한 경우
       - 해당 파일을 그대로 사용하여 파싱 스크립트 실행
       - 예: `python scripts/parse/parse_weapon_table.py src/request/weapons_table_new.html`
     - **방법 2**: 사용자가 HTML 텍스트를 제공한 경우
       1. 사용자 입력을 `src/request/` 폴더에 파일로 저장 (파일명은 의미있게 지정, 예: `weapons_table.html`)
       2. 기존 파싱 스크립트를 사용하여 파싱 (`scripts/parse/parse_weapon_table.py` 등)
       3. 파싱된 데이터를 기존 데이터 파일에 병합
       4. 결과 확인 및 검증
   - 사용자가 여러 카테고리를 한 번에 제공하는 경우, 모든 카테고리를 포함한 하나의 HTML 파일로 저장한 후 파싱한다
   - HTML 파일 형식은 코드 블록 형식(``` 카테고리명 ```) 또는 HTML 주석 형식(`<!-- 카테고리명 -->`) 모두 사용 가능하다
   - 파일 저장 시 기존 파일을 덮어쓰지 않고, 사용자가 의도한 파일명을 사용한다 (같은 카테고리의 업데이트는 기존 파일 덮어쓰기 가능)

3. **데이터 추출 패턴**:
   - 아이템 ID: `<a href="...item_detail/{id}">` 또는 `<a href="...monster_detail/{id}">`에서 추출
   - 이미지 URL: 기존 형식 사용 `https://maplestory.io/api/gms/200/item/{id}/icon?resize=2` 또는 `https://maplestory.io/api/gms/62/mob/{id}/icon?resize=2`
   - 레벨: `<td>` 태그의 숫자 값
   - 이름: `<td>` 태그의 텍스트
   - 추가 속성: 테이블 열에 따라 HP, EXP, 속성 등 추출

4. **카테고리 매핑**:
   - 무기 종류는 한글 이름과 영문 카테고리 ID를 매핑하는 딕셔너리를 사용
   - 예: `{'한손검': 'one-handed-sword', '두손검': 'two-handed-sword', '폴암': 'polearm', '활': 'bow', '석궁': 'crossbow', '완드': 'wand', '스태프': 'staff', '단검': 'dagger', '아대': 'gauntlet', '너클': 'knuckle', '총': 'gun', ...}`
   - 장비 아이템은 장비 종류(모자, 장갑, 신발, 전신, 상의, 하의, 방패, 귀걸이, 망토)와 직업군(전직업 공용, 전사, 마법사, 궁수, 도적, 해적)으로 구분된다
   - 장비 카테고리 매핑 예: `{'모자(헬멧)': 'hat', '모자': 'hat', '장갑': 'gloves', '신발': 'shoes', '전신': 'full-body', '상의': 'top', '하의': 'bottom', '방패': 'shield', '귀걸이': 'earring', '망토': 'cape', ...}`
   - 몬스터의 경우 지역 정보도 함께 추출하여 `regionIds` 배열에 추가
   - 카테고리 매핑은 `scripts/parse/parse_weapon_table.py`, `scripts/parse/parse_equipment_table.py` 등의 파싱 스크립트 내부에 정의되어 있다

5. **이미지 URL 형식**:
   - 기존 데이터와 일관성 유지: `https://maplestory.io/api/gms/200/item/{id}/icon?resize=2` (아이템)
   - 몬스터: `https://maplestory.io/api/gms/62/mob/{id}/icon?resize=2`
   - 제공된 HTML의 URL 형식과 다를 수 있으므로, 기존 데이터 형식을 확인하고 통일한다

6. **몬스터 데이터 파싱**:
   - 테이블에서 레벨, HP, EXP, 속성(약점/무효/반감) 정보를 추출
   - 속성 문자열은 쉼표로 구분되어 있으므로 파싱하여 배열로 변환 (예: "불속성약점, 얼음속성무효" → `["불속성약점", "얼음속성무효"]`)
   - 체경비는 계산값이므로 추출하지 않고, 필요시 HP/EXP로 계산

7. **지역 데이터 추가**:
   - 새로운 마을이나 지역이 발견되면 `src/data/region_data.json`에 추가
   - 지역 ID는 소문자 하이픈 형식 사용 (예: `masteria-crimsonwood`)
   - 부모-자식 관계는 `parentId` 필드로 표현

8. **타입 정의 업데이트**:
   - 새로운 카테고리나 필드가 필요하면 `src/types/` 디렉토리의 타입 정의 파일을 먼저 업데이트한다
   - 예: `ItemMediumCategory`에 새로운 무기 종류 추가
   - 타입 정의를 먼저 업데이트한 후 데이터를 추가하는 것이 중요하다

9. **HTML 파일 저장 위치 및 형식**:
   - 사용자가 제공한 HTML은 `src/request/` 폴더에 저장한다
   - 파일명은 의미있는 이름으로 지정한다 (예: `scroll.html`, `weapons_table.html`)
   - 사용자가 직접 HTML 파일을 만들거나 HTML 텍스트를 제공할 수 있다:
     - **코드 블록 형식**: 여러 코드 블록(``` 카테고리명 ... ```)을 포함할 수 있다
     - **HTML 주석 형식**: HTML 주석으로 카테고리를 구분 (`<!-- 카테고리명 -->` ... `<!-- 카테고리명 끝 -->`)
     - 모든 카테고리를 하나의 HTML 파일로 합쳐서 저장한다
     - 파일명은 카테고리나 데이터 타입을 나타내는 이름을 사용한다
   - `scripts/parse/parse_weapon_table.py` 스크립트는 두 가지 형식 모두 자동으로 감지하여 처리한다
   - 기존 파일을 덮어쓸지 새 파일을 만들지는 상황에 따라 결정한다

10. **데이터 검증**:
    - 파싱 후 결과 확인 (추가/업데이트된 항목 수)
    - 중복 데이터 확인 및 제거
    - 필수 필드 존재 여부 확인 (id, name, imageUrl 등)
    - 린터 오류 확인 (`read_lints` 도구 사용)

11. **이미지 URL 버전 통일**:
    - 기존 데이터 형식을 확인하고 그에 맞춘다
    - 아이템: `https://maplestory.io/api/gms/200/item/{id}/icon?resize=2`
    - 몬스터: `https://maplestory.io/api/gms/62/mob/{id}/icon?resize=2`
    - HTML에서 제공된 URL 형식과 다를 수 있으므로, 기존 데이터 형식을 우선한다

12. **파싱 스크립트 작성 시 주의사항**:
    - 파일 인코딩: 항상 UTF-8 사용 (`encoding='utf-8'`)
    - 정규식 패턴: HTML의 다양한 형식을 고려하여 유연하게 작성
    - 에러 처리: 파싱 실패 시 명확한 에러 메시지 출력
    - 카테고리 매핑: 매핑 딕셔너리는 스크립트 내부에 정의하거나 별도 파일로 관리
    - 여러 카테고리 처리: 하나의 HTML 파일에 여러 카테고리가 포함될 수 있으므로, 정규식으로 모든 카테고리 블록을 찾아 처리한다
    - 카테고리 구분 형식 지원: 코드 블록 형식(``` 카테고리명 ```)과 HTML 주석 형식(`<!-- 카테고리명 -->`) 모두 지원하도록 구현한다
    - 기존 스크립트(`parse_weapon_table.py`)는 두 가지 형식을 모두 지원하며, 우선 코드 블록 형식을 확인하고 없으면 HTML 주석 형식을 사용한다

13. **데이터 추가 순서**:
    - 타입 정의 업데이트 (`src/types/`) - 새로운 카테고리가 필요한 경우
    - 사용자 입력 HTML을 `src/request/` 폴더에 파일로 저장
    - 기존 파싱 스크립트 실행 또는 필요시 새로운 파싱 스크립트 작성
    - 데이터 병합 및 검증
    - 린터 오류 확인 및 수정

14. **반복 작업 패턴 (유동적 카테고리 추가)**:
    - 사용자가 HTML 파일을 제공하거나 HTML 텍스트를 제공할 수 있다:
      - **HTML 파일이 이미 있는 경우**: 해당 파일을 사용하여 바로 파싱 스크립트 실행
      - **HTML 텍스트를 제공한 경우**: 
        1. 사용자 입력을 `src/request/` 폴더에 의미있는 파일명으로 저장 (코드 블록 형식 또는 HTML 주석 형식 모두 가능)
        2. 기존 파싱 스크립트 확인 (`scripts/parse/parse_weapon_table.py`, `scripts/parse/parse_equipment_table.py` 등)
        3. 파싱 스크립트 실행 (파일 경로를 인자로 전달):
           - 무기: `python scripts/parse/parse_weapon_table.py src/request/파일명.html`
           - 장비: `python scripts/parse/parse_equipment_table.py src/request/파일명.html [직업군]` (직업군은 선택적, 기본값: common)
        4. 결과 확인 및 검증
    - 사용자가 여러 카테고리를 한 번에 제공하는 경우:
      - 모든 카테고리를 하나의 HTML 파일로 합쳐서 저장 (코드 블록 형식 또는 HTML 주석 형식)
      - 하나의 파싱 스크립트로 모든 카테고리를 한 번에 처리
    - 새로운 카테고리가 포함된 경우:
      - 타입 정의 업데이트 (`src/types/`)
      - 파싱 스크립트의 카테고리 매핑 딕셔너리에 추가
      - 파싱 스크립트 실행
    - 동일한 카테고리의 업데이트:
      - 기존 파일을 덮어쓰거나, 새 파일로 저장 후 파싱
      - 파싱 결과는 기존 데이터와 자동으로 병합됨 (중복 제거 및 업데이트)

15. **장비 아이템 파싱**:
    - 장비 아이템은 `scripts/parse/parse_equipment_table.py` 스크립트를 사용하여 파싱한다
    - 장비 아이템은 직업군별로 분류된다:
      - `majorCategory`: 직업군 (common, warrior, mage, archer, rogue, pirate)
      - `mediumCategory`: 장비 종류 (hat, gloves, shoes, full-body, top, bottom, shield, earring, cape)
    - 스크립트 실행 시 두 번째 인자로 직업군을 지정할 수 있다 (기본값: common)
      - 예: `python scripts/parse/parse_equipment_table.py src/request/equipment_warrior.html warrior`
    - HTML 주석 형식은 두 가지를 지원한다:
      - 형식 1: `<!-- ``` 카테고리명 -->` ... `<!-- ``` -->`
      - 형식 2: `<!-- 카테고리명 -->` ... `<!-- 카테고리명 끝 -->`
    - 스크립트는 두 형식을 자동으로 감지하여 처리한다 (형식 1을 먼저 확인하고, 없으면 형식 2 사용)


## 외부 웹사이트에서 지역별 몬스터 데이터 스크래핑

외부 웹사이트 (`xn--o80b01o9mlw3kdzc.com`)에서 지역별 몬스터 데이터를 스크래핑하여 업데이트하는 워크플로우:

1. **사용자 입력 형식**:
   - 사용자가 2개의 URL을 제공합니다:
     - 목록 페이지 URL: `https://xn--o80b01o9mlw3kdzc.com/monsternote?foundAt={region_value}`
     - 상세 페이지 예시 URL: `https://xn--o80b01o9mlw3kdzc.com/monster_detail/{monster_id}`
   - 예: "빅토리아 아일랜드의 모든 몬스터에 대해서 작업을 마저 진행하고 싶어요" + 목록 URL + 상세 예시 URL

2. **기존 스크립트 확인**:
   - 지역별로 이미 생성된 스크립트가 있는지 확인:
     - `scripts/parse/update_victoria_monsters_from_site.py` (빅토리아, foundAt=10)
     - `scripts/parse/update_world_travel_monsters_from_site.py` (세계여행, foundAt=world_travel)
     - `scripts/parse/update_orbis_monsters_from_site.py` (오르비스, foundAt=2000)
     - `scripts/parse/update_elnath_monsters_from_site.py` (엘나스, foundAt=2110)
     - `scripts/parse/update_ludibrium_monsters_from_site.py` (루디브리엄, foundAt=2200)
   - 새로운 지역인 경우 기존 스크립트를 복사하여 새 스크립트 생성

3. **스크립트 구조 (기존 스크립트 참고)**:
   - 스크립트는 다음 기능을 포함합니다:
     - `extract_monster_ids(list_html: str) -> List[str]`: 목록 페이지에서 몬스터 ID 추출 (정규식: `monster_detail/(\d+)`)
     - `parse_monster_detail_html(html_text: str, monster_id: str) -> ParsedMonsterDetail`: 상세 페이지 HTML 파싱
       - SPAWN 섹션: `href="[^"]*?/map_detail/(\d+)"` 패턴으로 mapId 추출, `<h3>` 태그에서 맵 이름 추출
       - GET 섹션: `href="[^"]*?/item_detail/(\d+)"` 패턴으로 itemId 추출, `<div class="drop-rate-box">`에서 드롭 확률 추출
     - `merge_monster_item_relations(...)`: `monster_item_relations.json` 병합 (dropRate 포함)
     - `merge_maps(...)`: `map_data.json` 병합 (monsterIds 필드 업데이트)
     - `merge_monster_region_ids(...)`: `monster_data.json`의 `regionIds` 필드 업데이트
     - `guess_{region}_region_id_from_map_id(map_id: str) -> str`: 맵 ID 접두어 기반으로 regionId 추론

4. **데이터 업데이트**:
   - **monster_item_relations.json**: 
     - 몬스터-아이템 관계 추가/업데이트
     - `dropRate` 필드 포함 (있을 경우)
     - 중복 제거: (monsterId, itemId) 쌍 기준
   - **map_data.json**:
     - 새로운 맵 추가 (최소 필드: id, name, regionId, mapType, monsterIds, isReleased)
     - 기존 맵의 `monsterIds` 배열에 해당 몬스터 ID 추가
     - 맵 이미지 URL 형식: `https://maplestory.io/api/gms/92/map/{map_id}/{type}` (render, minimap, icon)
   - **monster_data.json**:
     - 각 몬스터의 `regionIds` 배열 업데이트 (맵의 regionId 기반)

5. **regionId 추론 로직**:
   - 맵 ID 접두어 기반으로 regionId 추론:
     - 빅토리아: "100" → victoria-henesys, "101" → victoria-ellinia, "102" → victoria-perion 등
     - 세계여행: "500" → world-travel-japan, "701" → world-travel-taiwan, "800" → world-travel-china 등
     - 오르비스: "200" → orbis
     - 엘나스: "211" → ellin-forest
     - 루디브리엄: "22", "220", "221" → ludibrium
   - 9자리 미만 맵 ID는 휴리스틱 적용을 피하고 상위 지역으로만 귀속 (예: victoria)
   - 알 수 없는 경우는 해당 지역의 기본 regionId 사용 (예: "ludibrium", "orbis")

6. **HTML 저장**:
   - 스크래핑한 HTML은 `src/request/scraped_monsters/{region}/monster_{id}.html` 형식으로 저장
   - 예: `src/request/scraped_monsters/victoria/monster_100100.html`

7. **스크립트 실행**:
   - 명령어 형식: `python scripts/parse/update_{region}_monsters_from_site.py --delay 2.0`
   - 옵션:
     - `--list-url`: 목록 페이지 URL (기본값: 스크립트 내 상수)
     - `--output-dir`: HTML 저장 디렉토리 (기본값: `src/request/scraped_monsters/{region}`)
     - `--max-monsters`: 최대 처리할 몬스터 수 (테스트용, 선택적)
     - `--delay`: 각 페이지 사이 대기 시간 (초, 기본값: 1.0 또는 2.0)
     - `--skip-save-html`: HTML 저장 건너뛰기 (선택적)
   - **중요**: 서버 부하 방지를 위해 `--delay 2.0` 권장 (사용자 요청 시)

8. **스크립트 생성 패턴 (새로운 지역)**:
   - 기존 스크립트 중 하나를 복사 (예: `update_victoria_monsters_from_site.py`)
   - 파일명: `update_{region}_monsters_from_site.py`
   - 수정 사항:
     - `LIST_URL_DEFAULT`: 새로운 지역의 목록 URL
     - `SCRAPED_DIR_DEFAULT`: 새로운 지역의 HTML 저장 디렉토리
     - `guess_{region}_region_id_from_map_id` 함수: 새로운 지역의 맵 ID 접두어 매핑
     - `extract_{region}_monster_ids` 함수명 변경 (또는 `extract_monster_ids`로 통일)
   - 참고: 최근 스크립트들은 `extract_monster_ids`로 통일되어 있음

9. **작업 완료 후**:
   - 스크립트 실행 결과 요약 출력 확인 (추가/업데이트된 관계 수, 맵 수, 몬스터 수)
   - 각 JSON 파일이 올바르게 업데이트되었는지 확인
   - 린터 오류 확인 (필요시)

10. **사용 예시**:
    - 사용자 입력: "https://xn--o80b01o9mlw3kdzc.com/monsternote?foundAt=2200\nhttps://xn--o80b01o9mlw3kdzc.com/monster_detail/3000005\n이번엔 루디브리엄 지역입니다"
    - 처리: `update_ludibrium_monsters_from_site.py` 스크립트 확인 → 실행 (이미 존재하는 경우) 또는 새로 생성 후 실행
    - 실행: `python scripts/parse/update_ludibrium_monsters_from_site.py --delay 2.0`

11. **주의사항**:
    - IP 블록 방지를 위해 `--delay 2.0` 이상 사용 권장
    - 대량 크롤링 후 30~60분 휴식 권장
    - 네트워크 오류 발생 시 저장된 HTML 파일을 이용해 재파싱 가능 (스크립트 로직 수정 필요할 수도 있음)

## 몬스터 능력치 데이터 구조

몬스터 데이터에 상세 능력치 정보를 추가할 때:

1. **타입 정의**: `src/types/monster.ts`의 `Monster` 인터페이스에 `stats` 필드가 정의되어 있다:
   - `mp`: MP (마나 포인트, 선택적)
   - `knockbackDamage`: 넉백 가능 데미지 (숫자 또는 문자열, 예: "0+", 선택적)
   - `physicalDamage`: 물리 데미지 (선택적)
   - `magicDamage`: 마법 데미지 (선택적)
   - `physicalDefense`: 물리 방어력 (선택적)
   - `magicDefense`: 마법 방어력 (선택적)
   - `speed`: 속도 (선택적)
   - `requiredAccuracy`: 필요 명중 (해당 레벨에서의 필요 명중치, 소수점 가능, 선택적)
   - `mesos`: 메소 (드롭 메소량, 선택적)

2. **데이터 추가**: `src/data/monster_data.json`에서 해당 몬스터 객체에 `stats` 필드를 추가한다:
   ```json
   {
     "id": "9300128",
     "name": "블록퍼스",
     "level": 35,
     "hp": 1300,
     "exp": 72,
     "stats": {
       "mp": 0,
       "knockbackDamage": "0+",
       "physicalDamage": 105,
       "magicDamage": 115,
       "physicalDefense": 100,
       "magicDefense": 130,
       "speed": 0,
       "requiredAccuracy": 54.99,
       "mesos": 262.5
     }
   }
   ```

3. **UI 표시**: `src/components/MonsterDetailModal.tsx`에서:
   - 핵심 스탯 영역에 "능력치" 버튼이 표시된다
   - 버튼 클릭 시 `showStats` 상태가 토글되어 능력치 상세 정보가 표시된다
   - 능력치가 있는 경우에만 해당 필드가 카드 형태로 표시된다
   - 모든 필드는 선택적(optional)이므로, 일부 필드만 있어도 표시된다

4. **데이터 소스**: 
   - 외부 웹사이트(예: `xn--o80b01o9mlw3kdzc.com`)에서 몬스터 상세 페이지를 크롤링할 때 STATS 섹션에서 능력치 정보를 추출한다
   - 웹사이트의 몬스터 ID와 프로젝트의 몬스터 ID가 다를 수 있으므로, 몬스터 이름으로 매칭하여 업데이트한다

5. **주의사항**:
   - `knockbackDamage`는 숫자 또는 문자열("0+" 형식) 모두 가능하다
   - `requiredAccuracy`는 소수점을 포함할 수 있다 (예: 54.99)
   - 모든 필드는 선택적이므로, 데이터가 없는 경우 필드를 생략할 수 있다
   - 능력치 정보가 없는 몬스터의 경우 `stats` 필드 자체를 생략하거나 빈 객체로 둘 수 있다
